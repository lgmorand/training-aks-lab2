---
sectionid: keda
sectionclass: h2
title: Scaling with Keda
parent-id: autoscaling
---

As your app becomes more popular, you'll need to scale it to handle the increased load. In AKS, you can scale your app by increasing the number of replicas in your deployment. The Kubernetes [Horizontal Pod Autoscaler (HPA)](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/) will automatically scale your app based on CPU and/or memory utilization. But not all workloads rely on these metrics for scaling. If say, you need to scale your workload based on the number of items in a queue, HPA will not be sufficient.

This is where we take a different approach and deploy KEDA to scale our app. [KEDA is a Kubernetes-based Event Driven Autoscaler](https://keda.sh/). It allows you to scale your app on basically any metric. If there is a metric that KEDA can can access to, it can scale based on it. Under the covers KEDA, looks at the metrics and your scaling rules and eventually creates a HPA to do the actual scaling.

The AKS add-on for KEDA has already been installed in your cluster. If not, you can [install it in your namespace](https://keda.sh/docs/2.12/deploy/).

### Setting request and limits

When scaling on a performance metric, we need to let Kubernetes know how much compute and memory resources to allocate for each pod. We do this by setting the `requests` and `limits` in our deployment. The `requests` are the minimum amount of resources that Kubernetes will allocate for each pod. The `limits` are the maximum amount of resources that Kubernetes will allocate for each pod. Kubernetes will use these values to determine how many pods to run based on the amount of resources available on the nodes in the cluster.
In terms of the Horizontal Pod Autoscaler, he will use the requests (and not the limits) to define is new replicas must be created

Once set, your exercice will be to increase the CPU usage of the helloworld app and make it scale. You will have to:

- reduce the CPU request (to make scaling more easily)
- to configure a Keda object to handle the scaling
- to find an way to call the application with a cpu-consuming action (you don't need to change the source code)
- to use a 3rd party tool to simulate a high number of HTTP calls on your app
- depending on the way you are using your tool, you may (or may not) have to expose your application


{% collapsible %}

Open the `deployment.yaml` file, find the empty `resources: {}` block and replace it with the following to reduce the CPU request.

```yaml
spec:
  nodeSelector:
    kubernetes.io/os: linux
  containers:
    - image: acrtestengie.azurecr.io/helloworld:3445 # Registry + image name
      name: helloworld
      resources:
        requests:
          cpu: 24m
          memory: 128Mi
      ports:
        - containerPort: 80
          name: http
      env:
        - name: GREETEE
          value: AKS
```

Setting resource requests and limits is a best practice and should be done for all your deployments.

{% endcollapsible %}

When your deployment manifest is fully configured, run your deployment pipeline.

### Scaling with KEDA based on CPU utilization

Create a new `scaledobject.yaml` manifest for KEDA. Here we will scale the application up when the CPU utilization is greater than 50%. Don't forget to [read the documentation](https://keda.sh/docs/2.12/scalers/cpu/)

{% collapsible %}

```yaml
# scaledobject.yaml
apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: helloworld-scaledobject
spec:
  scaleTargetRef:
    name: helloworld
  triggers:
    - type: cpu
      metricType: Utilization
      metadata:
        value: "50"
```

The default values for minimum and maximum replica counts weren't included in our manifest above, but it will default to 0 and 100 respectively. In some cases, the minimum defaults to 1 so consult the documentation for the specific scaler you are using.
Apply the manifest to create the ScaledObject.

{% endcollapsible %}

Apply your manifest to your cluster

Run the following command to ensure the ScaledObject was created.

```bash
kubectl get scaledobject
```

Wait until the `READY` column shows `True`

```text
NAME                            SCALETARGETKIND      SCALETARGETNAME    MIN   MAX   TRIGGERS   AUTHENTICATION   READY   ACTIVE   FALLBACK   AGE
my-app-scaledobject   apps/v1.Deployment   helloworld               cpu                         True    True     Unknown    16s
```
